function plot_normals(normalVectors, labels, varargin);
% Code for plotting the normals of the data.  
% 
% Can operate in two modes:
%  In standalone mode, the normals are plotted at the origin with a unit sphere to
%    help the visualization.
%  In overlay mode, the normals are plotted on top of a (assumed to already exist) plot of the data.  
%    The previous plot could either be produced by hand, or generated by
%    the plot_subspaces function.
%

% Do a little input checking.

% Parse the inputs. 
if (mod(length(varargin), 2) ~= 0 ),
    error(['Extra Parameters passed to the function ''' mfilename ''' must be passed in pairs.']);
end
parameterCount = length(varargin)/2;
for parameterIndex = 1:parameterCount,
    parameterName = varargin{parameterIndex*2 - 1};
    parameterValue = varargin{parameterIndex*2};
    switch lower(parameterName)
        case 'displaymode'
            displayMode = parameterValue;
            if strcmpi(displayMode, 'standalone'),
                displayMode = 'standalone';
            elseif strcmpi(displayMode, 'overlay'),
                displayMode = 'overlay';
            else
                error('Value for displaymode not understood');
            end   
        case 'data'
            data = parameterValue;
            if (size(normalVectors,1) ~= size(data,1))),
                error('Dimension of data is inconsistent with the dimension of the normal vectors.')
            end
            if (size(normalVectors,3) ~= size(data,2)),
                error('Number of sets of normal vectors is inconsistent with the number of data points.')
            end
        case 'normalvectorplotmask'
            normalVectorPlotMask = parameterValue;
            if length(normalVectorPlotMask ~= size(normalVectors,2)),
                error('The mask in normalVectorPlotMask must have a value for every data point.');
            end
        case 'normalvectorcount'
            normalVectorCount = parameterValue;
            if length(normalVectorCount) ==1,
                normalVectorCount = repmat(normalVectorCount,1,size(normalVectors,1));
            elseif length(normalVectorCount) > 1,
                if length(normalVectorCount ~= size(normalVectors,1)),
                    error('normalVectorCount must be either a single value, or a vector the same as the length of the number of data points');
                end
            end
        case 'normalizationmode'
            normalizationMode = parameterValue;
            if strcmpi(normalizationMode, 'none')
                normalizationMode = 'none';
            elseif strcmpi(normalizationMode, 'unitize'),
                normalizationMode = 'unitize';
            elseif strcmpi(normalizationMode, 'autoscale'),
                normalizationMode = 'autoscale';
            elseif strcmpi(normalizationMode, 'unitizeThenAutoscale'),
                normalizationMode = 'unitizeThenAutoscale';
            else
                error('Value for normalizationMode not understood');
            end
        case 'apriorisamplelabels',
            aprioriSampleLabels = parameterValue;
        otherwise 
            error(['Sorry, the parameter ''' parameterName ''' is not recognized by the function ''' mfilename '''.']);
    end
end
% Set default values for some arrays that have not been initialized yet.
% By default, plot one normal vector for each data point.
if ~exist(normalVectorPlotMask,1),
    normalVectorPlotMask = ones(1,size(normalVectors,1));
end
if ~exist(normalVectorCount,1),
    normalVectorCount = ones(1,size(normalVectors,1));
end   

% Hold while drawing a bunch of elements to the current figure.
originalHoldState = ishold;
hold on;

% The order of the colors that will be used for plotting the vectors.
colorlist = 'krgbcmy';

for vector
normalVectorLengths = 

% Process the vectors according to the user's wishes.
switch normalizationMode
    case 'unitize'
        % Rescale the normalVectors to unit length.

        
    case 'autoscale'
        
    case 'unitizeThenAutoscale'
end

switch displayMode
    case 'standalone'
        
        
    case 'overlay'
        
        
end

% Restore original hold state
if ~originalHoldState,
    hold off;
end
